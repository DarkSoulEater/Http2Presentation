# HTTP (HTTP1)
## Что за протокол и зачем
Запросы на сервер поверх TCP.
## Проблемы
# HTTP2
## Основные фичи
Это бинарный протокол. 

Основные абстракции:
* Сообщение (Message) -
* Кадр (Frame) - 
* Поток (Stream) -

Итак вся информация передаваемая по HTTP2 пакуется в кадры, которые распределяются по потокам.

## Frame
### Base
```
HTTP Frame {
  # Заголовок
  Length (24), # Длина кадра в октетах не считая заголовка
  Type (8), # Тип кадра
  Flags (8), # Флаги (зависят от типа кадра)

  Reserved (1), # Зарезервированно (вегда 0)
  Stream Identifier (31), # Индетификатор потока, которому принадлежит кадр

  # Содержимое
  Frame Payload (..), # Полезная нагрузка
}
```

Кадр условно делится на заголовок и полезную нагрузку. (Рассказать про структуру кадра)
### Типа кадров
Рассказать про типы.

## Мультиплексирование потоков
Итак мы увидили, что каждый кадр принадлежит какому-то потоку. Это позволяет нам отправлять кадры из разных потоков в любом порядке (Какая-нибудь картина иллюстрирующая кадры). Это позвляет нам устанавливать приоретность получения данных.

Например: в середине получения какиз-то больних данных нам потребовалось запросить что-то еще. В HTTP1 нам бы пришлось ждать завершения отправки больших данных. В HTTP2 мы можем получить маленькие данные в середине получения больших данных, а после продолжить получение (Лучше дать именна и ссылаться на них + картинка для понимания)

Более того мы можем в любой момент прервать полученние данных, если они нам не нужны. В первой версии протокола такой возможности не было.

## HPACK
Как мы уже говорили, для заголовков используются кадры 0x01 и 0x09. Заголовог состоит из двух строк имя (name) и значение (value). В HTTP2 используется такие же заголовки для обратной совместимости, но есть несколько способов сжать их.

Заголовки передаются в виде произвольных сторк и их не получится передавать бинарно. Но можно воспользоваться кодированние Хаффмана. 

Про кодирование Хаффмана...

Вторая идея состоит в том, что в HTTP соединении заголовки в разных запросах часто имеют одинаковые имена или даже полностью идентичны. В таком случае можно создать кэширующую таблицу, которая будет запоминать данные заголовков и в дальшейшем при дублировании мы можем отправлять только индекс в этой таблице, а не строки целиком.

### Структура таблицы